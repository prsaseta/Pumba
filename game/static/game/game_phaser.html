{% extends 'base.html' %}

{% block content %}

{% load static %}

<script src="{% static 'game/phaser.min.js' %}"></script>

<script src = "{% static 'game/game_ui.js' %}"></script>

<script src = "{% static 'game/game_anims.js' %}"></script>

<div id="error-msg" class="error"></div>

<div id="game-div"></div>

<script>

    // ID de la partida
    var roomName = "{{ id }}";

    // Cuál es nuestro player index
    var playerIndex = {{ your_id }}

    // Cómo nos llamamos nosotros
    var playerName = undefined

    // Websocket al servidor
    var gameSocket = undefined
    var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
    try {
        gameSocket = new WebSocket(ws_scheme + "://" + window.location.host + '/ws/game/' + roomName + '/');
    } catch (error) {
        gameSocket = new WebSocket(ws_scheme + "://pumba-game.herokuapp.com" + '/ws/game/' + roomName + '/');
    }

    

    var config = {
        type: Phaser.AUTO,
        dom: {
            createContainer: true
        },
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        scale: {
            parent: 'game-div',
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: 1920,
            height: 1080
        },
        backgroundColor: "#678986"
    };

    // Objeto de juego global
    var game = new Phaser.Game(config);

    // Escena
    var scene = undefined

    // Estado de juego interno
    var game_state = {

    }

    // Cola de estados de juego
    var game_state_queue = [
        undefined
    ]

    // Apunta al último estado de juego procesado
    var game_state_index = 0

    // Si ya se está procesando la cola de estados o no
    var game_state_processing = false

    // Grupos de sprites y texto
    var piles_group = undefined
    var players_group = undefined
    var piles_group = undefined
    var hand_group = undefined
    var drawCounter_group = undefined
    var turnDirection_group = undefined
    var switchButtons_group = undefined
    var ui_group = undefined
    var beginMatch_group = undefined
    var wonMatch_group = undefined
    var divine_group = undefined
    var chat_group = undefined

    // Variables varias de la UI
    // Si ha robado este turno
    // 0: No (puede robar otra)
    // 1: Una vez (puede robar otra)
    // 2: Dos o más (No puede robar más)
    var drawn_this_turn = 0
    // Si puede terminar el turno o no
    // Verdadero o falso
    var can_end_turn = false
    // Si ha jugado un rey este turno
    // Verdadero o falso
    var has_played_king = false
    // Si ha jugado una carta este turno
    // Verdadero o falso
    var has_played_card = false

    // Si se sabe la carta que hay encima de la biblioteca por DIVINE, se guarda aquí
    var last_divined = undefined
    // Si un jugador roba una carta divinada, la guardamos aquí (se inicia a array de arrays luego)
    var players_divined = undefined

    function getPlayersDivined() {
        if (players_divined == undefined) {
            players_divined = []
            for(i = 0; i < game_state['players'].length; i++) {
                players_divined.push([])
            }
        }
        return players_divined
    }

    // Mensajes de chat
    var chat_messages = []
    // Cuánto scroll se ha hecho
    var chat_offset = 0
    // Por defecto 10 mensajes
    var max_messages_displayed = 10
    // Cuánto debería tener de longitud horizontal la ventana de chat
    var word_wrap_width = 300
    // Tamaño de fuente del chat
    var chat_text_size = 16
    // Se usa para calcular cuántas líneas tiene cada mensaje y romperlo adecuadamente
    var example_text = undefined

    // Carga las imágenes que vamos a necesitar
    function preload ()
    {
        // Sin loops ni nada porque se tiene que hacer en servidor
        this.load.image('BASTOS-ONE', "{% static 'BASTOS-ONE.png' %}")
        this.load.image('BASTOS-TWO', "{% static 'BASTOS-TWO.png' %}")
        this.load.image('BASTOS-COPY', "{% static 'BASTOS-COPY.png' %}")
        this.load.image('BASTOS-DIVINE', "{% static 'BASTOS-DIVINE.png' %}")
        this.load.image('BASTOS-FLIP', "{% static 'BASTOS-FLIP.png' %}")
        this.load.image('BASTOS-SWITCH', "{% static 'BASTOS-SWITCH.png' %}")
        this.load.image('BASTOS-JUMP', "{% static 'BASTOS-JUMP.png' %}")
        this.load.image('BASTOS-KING', "{% static 'BASTOS-KING.png' %}")

        this.load.image('COPAS-ONE', "{% static 'COPAS-ONE.png' %}")
        this.load.image('COPAS-TWO', "{% static 'COPAS-TWO.png' %}")
        this.load.image('COPAS-COPY', "{% static 'COPAS-COPY.png' %}")
        this.load.image('COPAS-DIVINE', "{% static 'COPAS-DIVINE.png' %}")
        this.load.image('COPAS-FLIP', "{% static 'COPAS-FLIP.png' %}")
        this.load.image('COPAS-SWITCH', "{% static 'COPAS-SWITCH.png' %}")
        this.load.image('COPAS-JUMP', "{% static 'COPAS-JUMP.png' %}")
        this.load.image('COPAS-KING', "{% static 'COPAS-KING.png' %}")

        this.load.image('ESPADAS-ONE', "{% static 'ESPADAS-ONE.png' %}")
        this.load.image('ESPADAS-TWO', "{% static 'ESPADAS-TWO.png' %}")
        this.load.image('ESPADAS-COPY', "{% static 'ESPADAS-COPY.png' %}")
        this.load.image('ESPADAS-DIVINE', "{% static 'ESPADAS-DIVINE.png' %}")
        this.load.image('ESPADAS-FLIP', "{% static 'ESPADAS-FLIP.png' %}")
        this.load.image('ESPADAS-SWITCH', "{% static 'ESPADAS-SWITCH.png' %}")
        this.load.image('ESPADAS-JUMP', "{% static 'ESPADAS-JUMP.png' %}")
        this.load.image('ESPADAS-KING', "{% static 'ESPADAS-KING.png' %}")

        this.load.image('OROS-ONE', "{% static 'OROS-ONE.png' %}")
        this.load.image('OROS-TWO', "{% static 'OROS-TWO.png' %}")
        this.load.image('OROS-COPY', "{% static 'OROS-COPY.png' %}")
        this.load.image('OROS-DIVINE', "{% static 'OROS-DIVINE.png' %}")
        this.load.image('OROS-FLIP', "{% static 'OROS-FLIP.png' %}")
        this.load.image('OROS-SWITCH', "{% static 'OROS-SWITCH.png' %}")
        this.load.image('OROS-JUMP', "{% static 'OROS-JUMP.png' %}")
        this.load.image('OROS-KING', "{% static 'OROS-KING.png' %}")

        this.load.image('card-back', "{% static 'card-back.png' %}")
        this.load.image('draw-card', "{% static 'draw-card.png' %}")
        this.load.image('end-turn', "{% static 'end-turn.png' %}")
        this.load.image('forced-draw', "{% static 'forced-draw.png' %}")

        this.load.image('button-espadas', "{% static 'button-espadas.png' %}")
        this.load.image('button-bastos', "{% static 'button-bastos.png' %}")
        this.load.image('button-oros', "{% static 'button-oros.png' %}")
        this.load.image('button-copas', "{% static 'button-copas.png' %}")

        this.load.audio('your-turn-sound', "{% static 'your-turn.mp3' %}")
        this.load.audio('enemy-turn-sound', "{% static 'enemy-turn.wav' %}")
        this.load.audio('play-card-sound', "{% static 'play-card.wav' %}")
        this.load.audio('draw-card-sound', "{% static 'draw-card.wav' %}")
        this.load.audio('game-won-sound', "{% static 'game-won.wav' %}")

        this.load.html('form', "{% static 'game/form.html' %}");
        this.load.html('chatdiv', "{% static 'game/chatdiv.html' %}");
    }

    // Inicializa el juego
    function create ()
    {
        //console.log(game)
        //console.log(this)
        // "This" es la escena de juego
        scene = this
        // Esto sirve para copiar sus caracteristicas para el chat
        example_text = scene.add.text(0, 0, "", {fontSize: chat_text_size, fontFamily: 'Arial', wordWrap: { width: word_wrap_width, useAdvancedWrap: true }})
        //drawBeginMatch()
        // Pide el estado de juego cuando todo esta listo
        if (gameSocket.readyState == gameSocket.OPEN) {
            gameSocket.send(JSON.stringify({
                'type': "game_state"
            }));
        }
        
        // Crea el form para enviar mensajes de chat
        var element = this.add.dom(180, 575).createFromCache('form');
        element.setScale(2, 2);

        // Crea un div para los mensajes de chat
        var chatboxdiv = this.add.dom(20, 250).createFromCache('chatdiv');
        chatboxdiv.setScale(1, 1);

        // Callback cuando pones una letra en el input de chat
        keyupChat = function (e) {
            if (e.keyCode === 13) {  // enter, return
                var messageInputDom = document.querySelector('#chat-input');
                var message = messageInputDom.value;
                message = message.trim()
                if (message != ""){
                    gameSocket.send(JSON.stringify({
                        'type': "chat_message",
                        'message': message
                    }));
                }
                messageInputDom.value = '';
            }
        }

        // Asignamos el callback
        element.addListener('keyup');
        element.on('keyup', keyupChat)

    }

    // Se ejecuta cada frame
    function update() {
        // Comprueba si hay estados pendientes de mostrar en pantalla, e inicia el proceso si es necesario
        //console.log("Estados: " + game_state_queue.length + ", índice: " + game_state_index + ", procesando: " + game_state_processing)
        if (game_state_processing == false && game_state_index < game_state_queue.length - 1){
            startPlayingStates()
        } else {
            if(game_state_queue.length - game_state_index - 1 > 0) {
                //console.log("ERROR")
            }
        }
    }

    // Se ejecuta cuando la partida termina
    function gameWon(player) {
        if (game_state["host"] == playerIndex) {
            drawBeginMatch()
        }
        drawWinner(player)
        scene.sound.play("game-won-sound")
        // Reseteamos también la cola de estados para liberar memoria
        game_state_queue = [undefined]
        game_state_index = 0

        has_played_card = false
        has_played_king = false
        can_end_turn = false
        drawn_this_turn = 0
    }

    function updateDisplay() {
        drawUI()
        drawYourHand()
        drawPlayers()
        drawPiles()
        drawDrawCounter()
        drawTurnDirection()
    }

    // Recibido un porcentaje, devuelve los píxeles
    function calculateCoordsX(x) {
        return x * game.scale.baseSize._width
    }
    function calculateCoordsY(y) {
        return y * game.scale.baseSize._height
    }
    // Función módulo porque JavaScript tiene retraso
    function modulo(n, m) {
        return ((n % m) + m) % m;
    }
    </script>

<script>

function appendToChatbox(message) {
    // Chatbox de phaser
    try {
        var cbdiv = document.getElementById("chatdiv")
        cbdiv.innerHTML += message + "<br>"
        cbdiv.scrollTop = cbdiv.scrollHeight
    } catch(err) {
        console.log(err)
    }
}

// Actualiza el estado de juego, pintando en pantalla lo que haga falta
// data: Paquete de datos recibido del servidor. Tiene un estado y una acción que ha llevado a dicho estado.
function updateGameFromState(data) {
    // El primer estado es "undefined"
    if (data == undefined){
        return undefined;
    }
    //console.log("Mostrando en pantalla estado: ")
    //console.log(data['action'])
    game_state["game_status"] = data["game_status"]
    game_state["last_suit"] = data["last_suit"]
    game_state["last_number"] = data["last_number"]
    game_state["last_effect"] = data["last_effect"]
    game_state["current_player"] = data["current_player"]
    game_state["next_player"] = data["next_player"]
    game_state["turn_direction"] = data["turn_direction"]
    game_state["draw_counter"] = data["draw_counter"]
    game_state["draw_pile"] = data["draw_pile"]
    game_state["play_pile"] = data["play_pile"]
    game_state["hand"] = data["hand"]
    game_state["players"] = data["players"]
    game_state["host"] = data["host"]

    // Recuperamos nuestro nombre
    if (playerName == undefined) {
        playerName = data["players"][playerIndex][0]
    }

    // Si se está esperando a empezar, muestra el botón para empezar la partida
    if (game_state["game_status"] != "PLAYING" && data["host"] == playerIndex) {
        drawBeginMatch()
    }
    // Si no se está esperando, actualiza el HUD
    if (game_state["game_status"] != "WAITING") {
        updateDisplay()
    }
}

// Añade un estado a la cola de estados, a actualizar a la más pronta conveniencia
// data: Paquete de datos recibido del servidor. Tiene un estado y una acción que ha llevado a dicho estado.
function addToStateQueue(data) {
    game_state_queue.push(data)
    //console.log("Añadido a la cola: " + String(data['action']))
    //console.log("Cola actual: " + String(game_state_queue))
}

// Se llama a esta función cuando haya un estado pendiente de mostrar en la pantalla
// Inicia la animación correspondiente al siguiente estado y actualiza el pointer
function startPlayingStates(){
    // Marcamos que ya estamos procesando los estados, para no pisarnos
    game_state_processing = true
    // Nos aseguramos de que haya algo que hacer
    if (game_state_index < game_state_queue.length -1) {  
        // Recogemos el estado siguiente
        game_state_index += 1
        var gstate = game_state_queue[game_state_index]

        // Hacemos animaciones y eso
        if (gstate != undefined) {
            // Si no ha pasado nada, repintamos directamente
            if (gstate['action'] == undefined) {
                // Repintamos la UI
                updateGameFromState(gstate)
                // Guardamos que hemos terminado
                game_state_processing = false
            // Ponemos la animación correspondiente a lo que ha pasado
            } else {
                if (gstate['action']['type'] == "end_turn"){
                    // Actualizamos el estado de los botones de la UI y variables varias
                    // Si el jugador actual ha empezado su turno:
                    if (gstate['current_player'] == playerIndex) {
                        drawn_this_turn = 0
                        can_end_turn = false
                    // Si acaba de terminarlo:
                    } else {
                        drawn_this_turn = 2
                        can_end_turn = false
                    }
                    has_played_king = false
                    has_played_card = false
                    // Animación de fin de turno
                    animateBeginTurn(gstate)
                } else if (gstate['action']['type'] == "begin_match") {
                    if (gstate['current_player'] == playerIndex) {
                        drawn_this_turn = 0
                        can_end_turn = false
                    } else {
                        drawn_this_turn = 2
                        can_end_turn = false
                    }
                    // Repintamos la UI
                    updateGameFromState(gstate)
                    // Guardamos que hemos terminado
                    game_state_processing = false
                } else if (gstate['action']['type'] == "game_won") {
                    // Repintamos la UI
                    updateGameFromState(gstate)
                    // Ponemos al ganador
                    gameWon(gstate['action']['player'])
                    // Vaciamos esto para la siguiente partida
                    players_divined = undefined
                    // Guardamos que hemos terminado
                    game_state_processing = false
                } else if (gstate['action']['type'] == "play_card") {
                    // Actualizamos el estado de los botones de la UI
                    // Si el jugador actual ha jugado carta:
                    if (gstate['current_player'] == playerIndex) {
                        can_end_turn = true
                        drawn_this_turn = 2
                        // Si la carta es un SWITCH, además dibujamos los botones de SWITCH
                        if (gstate['last_effect'] == 'SWITCH') {
                            drawSwitchButtons()
                        // Si ha jugado un rey, actualizamos la variable (para dibujar mejor cartas y cosas de la UI)
                        } else if (gstate['last_effect'] == "KING") {
                            has_played_king = true
                        }
                        has_played_card = true
                    }
                    // Eliminamos la carta que sabíamos que tenía si la juega
                    var pvined = getPlayersDivined()
                    for (i = 0; i < pvined[gstate['current_player']].length; i++){
                        var ccard = pvined[gstate['current_player']][i]
                        if (gstate['action']['card']['suit'] == ccard['suit'] && gstate['action']['card']['number'] == ccard['number']) {
                            pvined[gstate['current_player']].splice(i, 1)
                            break
                        }
                    }
                    animatePlayCard(gstate)
                } else if (gstate['action']['type'] == "draw_card"){
                    // Actualizamos el estado de los botones de la UI
                    // Si el jugador actual ha robado carta:
                    if (gstate['current_player'] == playerIndex) {
                        drawn_this_turn += 1
                        if (drawn_this_turn > 1) {
                            can_end_turn = true
                        }
                    }
                    // Si sabíamos qué carta era, nos la apuntamos
                    if (last_divined != undefined){
                        var pvined = getPlayersDivined()
                        pvined[gstate['current_player']].push(last_divined)
                        last_divined = undefined
                        divine_group.clear(true, true)
                    }
                    animateDrawCard(gstate)
                } else if (gstate['action']['type'] == "draw_card_forced"){
                    // Actualizamos el estado de los botones de la UI
                    // Si el jugador actual ha robado carta forzadamente:
                    if (gstate['current_player'] == playerIndex) {
                        drawn_this_turn = 2
                        can_end_turn = true
                    }
                    // Si sabíamos qué carta era, nos la apuntamos
                    if (last_divined != undefined){
                        var pvined = getPlayersDivined()
                        pvined[gstate['current_player']].push(last_divined)
                        last_divined = undefined
                        divine_group.clear(true, true)
                    }
                    animateDrawCardForced(gstate)
                } else {
                    // Repintamos la UI
                    updateGameFromState(gstate)
                    // Guardamos que hemos terminado
                    game_state_processing = false
                }
            }
        }
        console.log(players_divined)
        //console.log("Procesado índice: " + game_state_index)
        //console.log("Nº de estados: " + game_state_queue.length)
    } else {
        // Si no había nada que hacer...
        game_state_processing = false
    }
}

    // Hace lo que haga falta cuando llega un mensaje
    gameSocket.onmessage = function(e) {
        // Parsea el JSON
        var data = JSON.parse(e.data);
        // Recupera el tipo del mensaje
        var message_type = data['type']
        // Actualiza el estado de juego
        if (message_type == "game_state"){
            addToStateQueue(data)
            // Recuperamos lo que ha pasado y lo ponemos en el chat
            if (data['action'] != undefined) {
                var action = data['action']
                var cbox_message = undefined
                switch(String(action['type'])) {
                    case "begin_match":
                        cbox_message = "The match has begun!"
                        // Borramos el botón para empezar la partida
                        deleteBeginMatch()
                        break;
                    case "end_turn":
                        cbox_message = "Player " + action['player'] + " ends their turn."
                        break;
                    case "draw_card":
                        cbox_message = "Player " + action['player'] + " draws a card."
                        break;
                    case "draw_card_forced":
                        cbox_message = "Player " + action['player'] + " draws " + action['number'] + " cards and resets the counter."
                        break;
                    case "play_card":
                        cbox_message = "Player " + action['player'] + " plays a " + action['card']['number'] + " of " + action['card']['suit'] + "."
                        break;
                    case "game_won":
                        cbox_message = action['player'] + " wins the match!"
                        break;
                    case "switch":
                        cbox_message = "Player " + action['player'] + " changes the current suit to " + action['suit'] + "."
                        break;
                }
                appendToChatbox(cbox_message)
            }
        // Paquete es un mensaje de chat
        } else if (message_type == "chat_message"){
            var message = data['message'];
            var username = data['username'];
            var composed = username + ": " + message
            appendToChatbox(composed);
        // Paquete es una notificación de sistema
        } else if (message_type == "notification"){
            appendToChatbox(data['message'])
        // Paquete es un error
        } else if (message_type == "error") {
            appendToChatbox("Error: " + data['message'])
        // Paquete es un ACK del servidor (no hace nada)
        } else if (message_type == "ok"){
            //document.querySelector('#chat-log').value += ("OK: Command executed successfully" + '\n');
        // Paquete es una notificación de que el socket se está cerrando desde el servidor
        } else if (message_type == "disconnect") {
            document.getElementById("error-msg").innerHTML += data['reason'] + "<br>"
        // Paquete es una notificación por usar la carta DIVINE
        } else if (message_type == "divination") {
            appendToChatbox("The next card drawn will be a " + data['card']['number'] + " of " + data['card']['suit'] + ".");
            // Nos guardamos cuál carta es aparte para mostrarla si alguien la roba
            last_divined = data['card']
            drawDivine(data['card']['suit'], data['card']['number'])
        }
    }

    // Qué hacer si se cierra el websocket de forma inesperada
    // Muestra un mensaje en la parte de arriba de la pantalla
    gameSocket.onclose = function(e) {
        document.getElementById("error-msg").innerHTML += "The connection to the server was lost<br>"
    };

    // Cuando el WebSocket está listo tras abrir la página, pide el estado de la partida al servidor
    gameSocket.onopen = function(event) {
        gameSocket.send(JSON.stringify({
            'type': "game_state"
        }));
    }
</script>

{% endblock %}
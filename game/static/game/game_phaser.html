{% extends 'base.html' %}

{% block content %}

{% load static %}

<script src="{% static 'game/phaser.min.js' %}"></script>

<div id="game-div"></div>

<script>

    // ID de la partida
    var roomName = "{{ id }}";

    // Cuál es nuestro player index
    var playerIndex = {{ your_id }}

    // Websocket al servidor
    var gameSocket = undefined
    var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
    try {
        gameSocket = new WebSocket(
        ws_scheme + "://" + window.location.host +
        '/ws/game/' + roomName + '/');
    } catch (error) {
        gameSocket = new WebSocket(
        ws_scheme + "://pumba-game.herokuapp.com" +
        '/ws/game/' + roomName + '/');
    }

    

    var config = {
        type: Phaser.AUTO,
        dom: {
            createContainer: true
        },
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 }
            }
        },
        scene: {
            preload: preload,
            create: create
        },
        scale: {
            parent: 'game-div',
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: 1920,
            height: 1080
        }
    };

    // Objeto de juego global
    var game = new Phaser.Game(config);

    // Escena
    var scene = undefined

    // Estado de juego interno
    var game_state = {

    }

    // Grupos de sprites y texto
    var piles_group = undefined
    var players_group = undefined
    var piles_group = undefined
    var hand_group = undefined
    var drawCounter_group = undefined
    var turnDirection_group = undefined
    var switchButtons_group = undefined
    var ui_group = undefined
    var beginMatch_group = undefined
    var wonMatch_group = undefined
    var divine_group = undefined
    var chat_group = undefined

    // Mensajes de chat
    var chat_messages = []
    // Cuánto scroll se ha hecho
    var chat_offset = 0
    // Por defecto 10 mensajes
    var max_messages_displayed = 10
    // Cuánto debería tener de longitud horizontal la ventana de chat
    var word_wrap_width = 300
    // Tamaño de fuente del chat
    var chat_text_size = 16
    // Se usa para calcular cuántas líneas tiene cada mensaje y romperlo adecuadamente
    var example_text = undefined

    // Carga las imágenes que vamos a necesitar
    function preload ()
    {
        // Sin loops ni nada porque se tiene que hacer en servidor
        this.load.image('BASTOS-ONE', "{% static 'BASTOS-ONE.png' %}")
        this.load.image('BASTOS-TWO', "{% static 'BASTOS-TWO.png' %}")
        this.load.image('BASTOS-COPY', "{% static 'BASTOS-COPY.png' %}")
        this.load.image('BASTOS-DIVINE', "{% static 'BASTOS-DIVINE.png' %}")
        this.load.image('BASTOS-FLIP', "{% static 'BASTOS-FLIP.png' %}")
        this.load.image('BASTOS-SWITCH', "{% static 'BASTOS-SWITCH.png' %}")
        this.load.image('BASTOS-JUMP', "{% static 'BASTOS-JUMP.png' %}")
        this.load.image('BASTOS-KING', "{% static 'BASTOS-KING.png' %}")

        this.load.image('COPAS-ONE', "{% static 'COPAS-ONE.png' %}")
        this.load.image('COPAS-TWO', "{% static 'COPAS-TWO.png' %}")
        this.load.image('COPAS-COPY', "{% static 'COPAS-COPY.png' %}")
        this.load.image('COPAS-DIVINE', "{% static 'COPAS-DIVINE.png' %}")
        this.load.image('COPAS-FLIP', "{% static 'COPAS-FLIP.png' %}")
        this.load.image('COPAS-SWITCH', "{% static 'COPAS-SWITCH.png' %}")
        this.load.image('COPAS-JUMP', "{% static 'COPAS-JUMP.png' %}")
        this.load.image('COPAS-KING', "{% static 'COPAS-KING.png' %}")

        this.load.image('ESPADAS-ONE', "{% static 'ESPADAS-ONE.png' %}")
        this.load.image('ESPADAS-TWO', "{% static 'ESPADAS-TWO.png' %}")
        this.load.image('ESPADAS-COPY', "{% static 'ESPADAS-COPY.png' %}")
        this.load.image('ESPADAS-DIVINE', "{% static 'ESPADAS-DIVINE.png' %}")
        this.load.image('ESPADAS-FLIP', "{% static 'ESPADAS-FLIP.png' %}")
        this.load.image('ESPADAS-SWITCH', "{% static 'ESPADAS-SWITCH.png' %}")
        this.load.image('ESPADAS-JUMP', "{% static 'ESPADAS-JUMP.png' %}")
        this.load.image('ESPADAS-KING', "{% static 'ESPADAS-KING.png' %}")

        this.load.image('OROS-ONE', "{% static 'OROS-ONE.png' %}")
        this.load.image('OROS-TWO', "{% static 'OROS-TWO.png' %}")
        this.load.image('OROS-COPY', "{% static 'OROS-COPY.png' %}")
        this.load.image('OROS-DIVINE', "{% static 'OROS-DIVINE.png' %}")
        this.load.image('OROS-FLIP', "{% static 'OROS-FLIP.png' %}")
        this.load.image('OROS-SWITCH', "{% static 'OROS-SWITCH.png' %}")
        this.load.image('OROS-JUMP', "{% static 'OROS-JUMP.png' %}")
        this.load.image('OROS-KING', "{% static 'OROS-KING.png' %}")

        this.load.image('card-back', "{% static 'card-back.png' %}")
        this.load.image('draw-card', "{% static 'draw-card.png' %}")
        this.load.image('end-turn', "{% static 'end-turn.png' %}")

        this.load.html('form', "{% static 'game/form.html' %}");
    }

    // Inicializa el juego
    function create ()
    {
        //console.log(game)
        //console.log(this)
        // "This" es la escena de juego
        scene = this
        // Esto sirve para copiar sus caracteristicas para el chat
        example_text = scene.add.text(0, 0, "", {fontSize: chat_text_size, fontFamily: 'Arial', wordWrap: { width: word_wrap_width, useAdvancedWrap: true }})
        //drawBeginMatch()
        // Pide el estado de juego cuando todo esta listo
        gameSocket.send(JSON.stringify({
            'type': "game_state"
        }));
        // Dibuja la ventana de chat
        drawChatbox()
        
        // Crea el form para enviar mensajes de chat
        var element = this.add.dom(400, 100).createFromCache('form');
        element.setScale(2, 2);

        // Callback cuando pones una letra en el input de chat
        keyupChat = function (e) {
            if (e.keyCode === 13) {  // enter, return
                var messageInputDom = document.querySelector('#chat-input');
                var message = messageInputDom.value;
                message = message.trim()
                if (message != ""){
                    gameSocket.send(JSON.stringify({
                        'type': "chat_message",
                        'message': message
                    }));
                }
                messageInputDom.value = '';
            }
        }

        // Asignamos el callback
        element.addListener('keyup');
        element.on('keyup', keyupChat)

    }

    // Dibuja la ventana de chat
    function drawChatbox() {
        // Borra el grupo
        if (chat_group == undefined) {
            chat_group = scene.add.group(true, false)
        } else {
            chat_group.clear(true, true)
        }

        // Crea los objetos texto
        // TODO Como empieza a mostrar desde el "principio", si los mensajes son largos a veces no te muestra el último mensaje enviado
        var messages_left_to_display = Math.min(max_messages_displayed, chat_messages.length)
        var next_offset = 100
        i = 0
        while (messages_left_to_display > 0) {
            var last_text = scene.add.text(1920 - 300, next_offset, chat_messages[chat_offset + i], {fontSize: chat_text_size, fontFamily: 'Arial', wordWrap: { width: word_wrap_width, useAdvancedWrap: true }})
            var result = last_text.getWrappedText(chat_messages[chat_offset + i])
            chat_group.add(last_text)
            next_offset += result.length * 25
            messages_left_to_display -= result.length
            i++
        }
        /*
        for (j = 0; j < Math.min(max_messages_displayed, chat_messages.length); j++) {
            console.log(":D????")
            scene.add.text(1920 - 300, 300 + i*25, chat_messages[chat_offset + i], {fontSize: chat_text_size, fontFamily: 'Arial', wordWrap: { width: word_wrap_width, useAdvancedWrap: true }})
        }
        */
    }

    // Se ejecuta cuando recibes un divine
    function drawDivine(suit, number) {
        if (divine_group == undefined) {
            divine_group = scene.add.group()
        } else {
            divine_group.clear(true, true)
        }

        var divination = scene.add.sprite(-30 -254 - 254 / 2 + 1920 / 2, 1080 / 3, suit + "-" + number)
        var divText = scene.add.text(-30 - 60 -254 - 254 / 2 + 1920 / 2, 20 + 352 / 2 + 1080 / 3, "Divination", { fontFamily: 'Verdana', fontSize: 36 })
        divine_group.add(divination)
        divine_group.add(divText)

        function clearDivination() {
            divine_group.clear(true, true)
        }

        divination.setInteractive()
        divination.on("pointerup", clearDivination)
    }

    // Se ejecuta cuando la partida termina
    function gameWon(player) {
        drawBeginMatch()
        drawWinner(player)
    }

    function drawWinner(player) {
        if (wonMatch_group == undefined) {
            wonMatch_group = scene.add.group()
        } else {
            wonMatch_group.clear(true, true)
        }
        var winner = scene.add.text(1920 / 3, 150 + 1080 - 1080 / 3, player + " wins the match!", { fontFamily: 'Verdana', fontSize: 80 })
        wonMatch_group.add(winner)
        winner.setDepth(9999)
    }

    // Pone el botón para empezar la partida
    function drawBeginMatch() {
        if (beginMatch_group == undefined) {
            beginMatch_group = scene.add.group()
        }
        var begin_match = scene.add.text(1920 / 3, 1080 - 1080 / 3, "Begin match", { fontFamily: 'Verdana', fontSize: 80 })
        beginMatch_group.add(begin_match)
        begin_match.setInteractive()
        begin_match.setDepth(9999)

        function beginMatch() {
            gameSocket.send(JSON.stringify({
                'type': "begin_match"
            }));
        }

        begin_match.on("pointerup", beginMatch)
    }

    // Borra el botón de empezar partida y la notificación de quién la ha ganado
    function deleteBeginMatch() {
        if (beginMatch_group != undefined) {
            beginMatch_group.clear(true, true)
        }
        if (wonMatch_group != undefined){
            wonMatch_group.clear(true, true)
        }
    }

    function updateDisplay() {
        drawUI()
        drawYourHand()
        drawPlayers()
        drawPiles()
        drawDrawCounter()
        drawTurnDirection()
    }

    // Dibuja la UI básica
    function drawUI() {
        if (ui_group == undefined) {
            ui_group = scene.add.group()
            var end_turn = scene.add.sprite(1920 - 200, 650, "end-turn")
            var draw_card = scene.add.sprite(1920 - 200, 500, "draw-card")

            end_turn.setInteractive()
            draw_card.setInteractive()

            ui_group.add(end_turn)
            ui_group.add(draw_card)

            function endTurn() {
                deleteSwitchButtons()
                gameSocket.send(JSON.stringify({
                    'type': "begin_turn"
                }));
            }

            function drawCard() {
                gameSocket.send(JSON.stringify({
                    'type': "draw_card"
                }));
            }

            end_turn.on("pointerup", endTurn)
            draw_card.on("pointerup", drawCard)
        }
    }

    // Crea los botones de SWITCH
    // Ojo: Hay que borrarlos después y poner que aparezcan solamente cuando haga falta
    function drawSwitchButtons() {
        if (switchButtons_group != undefined) {
            //switchButtons_group.clear(true, true)
        } else {
            switchButtons_group = scene.add.group()
        }

        var espadas = scene.add.text(1920 - 200, 700, "ESPADAS", { fontFamily: 'Verdana', fontSize: 30 });
        var bastos = scene.add.text(1920 - 200, 700 + 50, "BASTOS", { fontFamily: 'Verdana', fontSize: 30 });
        var copas = scene.add.text(1920 - 200, 700 + 100, "COPAS", { fontFamily: 'Verdana', fontSize: 30 });
        var oros = scene.add.text(1920 - 200, 700 + 150, "OROS", { fontFamily: 'Verdana', fontSize: 30 });

        espadas.setInteractive()
        bastos.setInteractive()
        copas.setInteractive()
        oros.setInteractive()

        function switchEspadas() {
            gameSocket.send(JSON.stringify({
                'type': "switch_effect",
                'switch': "ESPADAS"
            }));
            deleteSwitchButtons()
        }
        
        function switchBastos() {
            gameSocket.send(JSON.stringify({
                'type': "switch_effect",
                'switch': "BASTOS"
            }));
            deleteSwitchButtons()
        }

        function switchCopas() {
            gameSocket.send(JSON.stringify({
                'type': "switch_effect",
                'switch': "COPAS"
            }));
            deleteSwitchButtons()
        }

        function switchOros() {
            gameSocket.send(JSON.stringify({
                'type': "switch_effect",
                'switch': "OROS"
            }));
            deleteSwitchButtons()
        }

        espadas.on('pointerup',switchEspadas)
        bastos.on('pointerup',switchBastos)
        copas.on('pointerup',switchCopas)
        oros.on('pointerup',switchOros)

        switchButtons_group.add(espadas)
        switchButtons_group.add(bastos)
        switchButtons_group.add(copas)
        switchButtons_group.add(oros)
        
    }

    function deleteSwitchButtons() {
        if (switchButtons_group != undefined) {
            switchButtons_group.clear(true, true)
        }
    }

    function drawTurnDirection() {
        if (turnDirection_group != undefined) {
            turnDirection_group.clear(true, true)
        } else {
            turnDirection_group = scene.add.group()
        }

        var turnDirText = scene.add.text(1920 / 2, 20, game_state["turn_direction"], { fontFamily: 'Verdana', fontSize: 30 });
        turnDirection_group.add(turnDirText)
    }

    // Muestra en pantalla el contador de robo (si hay)
    function drawDrawCounter() {
        // Borramos lo que hubiera, si lo hay
        if (drawCounter_group != undefined) {
            drawCounter_group.clear(true, true)
        } else {
            drawCounter_group = scene.add.group()
        }

        if (game_state["draw_counter"] > 0) {
            var drawCounterText = scene.add.text(1600, 20, "Counter: " + game_state["draw_counter"], { fontFamily: 'Verdana', fontSize: 30 });
            drawCounter_group.add(drawCounterText)
        }
    }

    // Pone en pantalla las pilas de juego
    // TODO Poner las cartas una encima de otra visualmente para ponerlo bonito
    function drawPiles() {
        // Borramos lo que hubiera, si lo hay
        if (piles_group != undefined) {
            piles_group.clear(true, true)
        } else {
            piles_group = scene.add.group()
        }

        var playPileDisp = scene.add.sprite(-254 / 2 + 1920 / 2, 1080 / 3, game_state["last_suit"] + "-" + game_state["last_number"])
        var playPileText = scene.add.text(-254 / 2 + 1920 / 2, 50 + 254 / 2 + 1080 / 3, game_state["play_pile"], { fontFamily: 'Verdana', fontSize: 36 });
        var drawPileDisp = scene.add.sprite(-254 / 2 + 300 + 1920 / 2, 1080 / 3, "card-back")
        var drawPileText = scene.add.text(-254 / 2 + 300 + 1920 / 2, 50 + 254 / 2 + 1080 / 3, game_state["draw_pile"], { fontFamily: 'Verdana', fontSize: 36 });
        piles_group.add(playPileDisp)
        piles_group.add(drawPileDisp)
        piles_group.add(drawPileText)
        piles_group.add(playPileText)
    }

    // Pone en pantalla los indicadores de otros jugadores
    function drawPlayers(){
        // Borramos lo que hubiera, si lo hay
        if (players_group != undefined) {
            players_group.clear(true, false)
        } else {
            players_group = scene.add.group()
        }

        var num_players = game_state["players"].length
        var players_left = Math.ceil((num_players - 1) / 2)
        var players_right = Math.floor((num_players - 1) / 2)

        // Como el orden es izquierda-derecha y clockwise por defecto, le damos la vuelta
        // No trivial ponerlo bonito por los bordes, así que una lista simple y a tomar por culo
        /*
        for(i = 1; i <= players_right; i++){
            scene.add.text(100, 100 + i * 100, game_state["players"][modulo(playerIndex + i, num_players)][0], { fontFamily: 'Verdana', fontSize: 40 });
            scene.add.text(100, 100 + i * 100 + 50, game_state["players"][modulo(playerIndex + i, num_players)][1], { fontFamily: 'Verdana', fontSize: 40 });
        }
        for(i = 1; i <= players_left; i++){
            scene.add.text(1920 - 100, 100 + i * 100, game_state["players"][modulo(0 + i, num_players)][0], { fontFamily: 'Verdana', fontSize: 40 });
            scene.add.text(1920 - 100, 100 + i * 100 + 50, game_state["players"][modulo(0 + i, num_players)][1], { fontFamily: 'Verdana', fontSize: 40 });
        }
        */

        for(i = 0; i < num_players; i++){
            var text = game_state["players"][i][0] + " " + game_state["players"][i][1]
            if (game_state["players"][i][2] == "True") {
                text = "(AI) " + text
            }
            if (game_state["current_player"] == i) {
                text = text + " | CURRENT"
            }
            var ptext = scene.add.text(20, 20 + i * 70, text, { fontFamily: 'Verdana', fontSize: 36 });
            players_group.add(ptext)
            //scene.add.text(100, 100 + i * 100 + 50, game_state["players"][i][1], { fontFamily: 'Verdana', fontSize: 40 });
        }
    }

    // Pone en pantalla tu mano actual, borrando lo que hubiere
    function drawYourHand() {
        // Buscamos el grupo, y si no está, lo borramos
        if (hand_group != undefined) {
            hand_group.clear(true, true)
        } else {
            hand_group = scene.add.group()
        }

        // Creamos los sprites
        // Centro alrededor del cual se ponen las cartas
        var center = (1920 / 2) + 254 / 2
        // Número de cartas que hay que distribuir
        var card_count = game_state["hand"].length
        // Ángulo alrededor del cual distribuir las cartas
        var angle = 45
        // Radio horizontal alrededor del cual distribuir las cartas (pixeles)
        var radius = 500 + (card_count - 1) * 100
        radius = Math.min(radius, 1920)
        for (i = 0; i < card_count; i++){
            // Carta actual
            var card = game_state["hand"][i]
            var disp = scene.add.sprite(((1920 - radius) / 2) + ((radius * i) / card_count), 1080 - 352/2 - 30, card[0] + "-" + card[1]).setInteractive();
            disp.setScale(Math.min(1.5 / Math.log(card_count), 1.25))
            disp.setDepth(i)
            //disp.setAngle((-angle) + (angle / card_count) * (i + 1))
            // TODO Probar esto: this.add.image(0, 0, 'sky').setOrigin(0, 0)
            // Le añadimos una propiedad no nativa al objeto, que es básicamente el índice de la carta en la mano
            // Se usa para ordenar la mano gráficamente y enviar comandos al servidor
            disp.custom_var = i
            hand_group.add(disp)

            // Los muertos de JavaScript y su retraso con las funciones me cago en dios
            // Hace que al hacer mouseover en la carta la ponga más grande
            var child = disp
            function changeScale2(child) {
                return function() {
                    child.setScale(1.5)
                    child.setDepth(10000)
                    child.setY(child.y - 100)
                }
            }
            function changeScale1(child) {
                return function() {
                    child.setScale(Math.min(1.5 / Math.log(card_count), 1.25))
                    child.setDepth(child.custom_var)
                    child.setY(child.y + 100)
                }
            }
            function playCardFromHand(child, suit, number) {
                return function() {
                    gameSocket.send(JSON.stringify({
                        'type': "play_card",
                        'index': child.custom_var
                    }));
                }
            }
            child.on('pointerover',changeScale2(child))
            child.on('pointerout',changeScale1(child))
            child.on('pointerup',playCardFromHand(child, card[0], card[1]))
        }
    }

    // Recibido un porcentaje, devuelve los píxeles
    function calculateCoordsX(x) {
        return x * game.scale.baseSize._width
    }
    function calculateCoordsY(y) {
        return y * game.scale.baseSize._height
    }
    // Función módulo porque JavaScript tiene retraso
    function modulo(n, m) {
        return ((n % m) + m) % m;
    }
    </script>

<script>

function appendToChatbox(message) {
        // Chatbox de phaser
        // Rompemos el mensaje en líneas
        try {
            var strings = example_text.getWrappedText(message)
            // Por cada línea, lo añadimos a la lista
            for (i = 0; i < strings.length; i++){
                chat_messages.push(strings[i])
                // Si ya se ha llenado el chat, hacemos scroll
                if (chat_messages.length > max_messages_displayed){
                    chat_offset += 1
                }
            }
            // Es posible que esto se ejecute mientras Phaser no está preparado todavía
            if (scene != undefined) {
                drawChatbox()
            }
        } catch(err) {
            console.log(err)
        }
    }

    // Hace lo que haga falta cuando llega un mensaje
    gameSocket.onmessage = function(e) {
        // Parsea el JSON
        var data = JSON.parse(e.data);
        // Recupera el tipo del mensaje
        var message_type = data['type']
        // Actualiza el estado de juego
        if (message_type == "game_state"){
            game_state["game_status"] = data["game_status"]
            game_state["last_suit"] = data["last_suit"]
            game_state["last_number"] = data["last_number"]
            game_state["last_effect"] = data["last_effect"]
            game_state["current_player"] = data["current_player"]
            game_state["next_player"] = data["next_player"]
            game_state["turn_direction"] = data["turn_direction"]
            game_state["draw_counter"] = data["draw_counter"]
            game_state["draw_pile"] = data["draw_pile"]
            game_state["play_pile"] = data["play_pile"]
            game_state["hand"] = data["hand"]
            game_state["players"] = data["players"]
            // Actualiza el display
            if (game_state["game_status"] == "WAITING") {
                drawBeginMatch()
            } else {
                updateDisplay()
            }

            // Recuperamos lo que ha pasado y lo ponemos en el chat
            if (data['action'] != undefined) {
                var action = data['action']
                var cbox_message = undefined
                switch(String(action['type'])) {
                    case "begin_match":
                        cbox_message = "The match has begun!"
                        // Borramos el botón para empezar la partida
                        deleteBeginMatch()
                        break;
                    case "end_turn":
                        cbox_message = "Player " + action['player'] + " ends their turn."
                        break;
                    case "draw_card":
                        cbox_message = "Player " + action['player'] + " draws a card."
                        break;
                    case "draw_card_forced":
                        cbox_message = "Player " + action['player'] + " draws " + action['number'] + " cards and resets the counter."
                        break;
                    case "play_card":
                        cbox_message = "Player " + action['player'] + " plays a " + action['card']['number'] + " of " + action['card']['suit'] + "."
                        // Mostramos los botones de Switch si hace falta
                        if (game_state["last_effect"] == "SWITCH" && game_state["current_player"] == playerIndex) {
                            drawSwitchButtons()
                        }
                        break;
                    case "game_won":
                        cbox_message = action['player'] + " wins the match!"
                        gameWon(action['player'])
                        break;
                    case "switch":
                        cbox_message = "Player " + action['player'] + " changes the current suit to " + action['suit'] + "."
                        break;
                }
                appendToChatbox(cbox_message)
            }
        } else if (message_type == "chat_message"){
            var message = data['message'];
            var username = data['username'];
            var composed = username + ": " + message
            appendToChatbox(composed);
        // Notificación de sistema
        } else if (message_type == "notification"){
            appendToChatbox(data['message'])
        } else if (message_type == "error") {
            appendToChatbox("Error: " + data['message'])
        // ACK del servidor (ahora mismo no hace nada)
        } else if (message_type == "ok"){
            //document.querySelector('#chat-log').value += ("OK: Command executed successfully" + '\n');
        // Para cuando se usa DIVINE
        } else if (message_type == "divination") {
            appendToChatbox("The next card drawn will be a " + data['card']['number'] + " of " + data['card']['suit'] + ".");
            drawDivine(data['card']['suit'], data['card']['number'])
        }
    }

    // Qué hacer si se cierra el websocket de forma inesperada
    gameSocket.onclose = function(e) {
        console.error('Chat socket closed unexpectedly');
        //document.getElementById("error-msg").textContent += "The connection to the server was lost";
    };

    // Cuando el WebSocket está listo tras abrir la página, pide el estado de la partida
    // al servidor
    gameSocket.onopen = function(event) {
        gameSocket.send(JSON.stringify({
            'type': "game_state"
        }));
    }
</script>

{% endblock %}